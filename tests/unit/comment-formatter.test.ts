/**
 * Unit tests for CommentFormatter (Feature 5, Task 5.5)
 * Tests all formatting functions with comprehensive edge cases
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  CommentFormatter,
  createCommentFormatter,
  FormattedTestResults,
  HealedTest,
  PerformanceMetrics,
} from '../../src/github/comment-formatter.js';
import { TestResult, TestStatus, ExecutionSummary, TestError, ErrorType } from '../../src/types/executor-types.js';

describe('CommentFormatter', () => {
  let formatter: CommentFormatter;

  beforeEach(() => {
    formatter = createCommentFormatter();
  });

  describe('createCommentFormatter', () => {
    it('should create a CommentFormatter instance', () => {
      expect(formatter).toBeInstanceOf(CommentFormatter);
    });
  });

  describe('formatTestResults', () => {
    it('should format complete test results with all sections', () => {
      const results = createSampleResults();
      const comment = formatter.formatTestResults(results);

      expect(comment).toContain('## üß™ API Test Results');
      expect(comment).toContain('### Summary');
      expect(comment).toContain('‚úÖ **2 passed**');
      expect(comment).toContain('‚ùå **1 failed**');
      expect(comment).toContain('### ‚úÖ Passed Tests');
      expect(comment).toContain('### ‚ùå Failed Tests');
    });

    it('should include healed tests section when present', () => {
      const results = createSampleResults();
      const comment = formatter.formatTestResults(results);

      expect(comment).toContain('### üîß Self-Healed Tests');
      expect(comment).toContain('auto-fixed');
    });

    it('should include performance metrics when present', () => {
      const results = createSampleResults();
      const comment = formatter.formatTestResults(results);

      expect(comment).toContain('### üìà Performance Metrics');
      expect(comment).toContain('Average Response Time');
      expect(comment).toContain('Slowest Endpoint');
    });

    it('should include links section when URLs provided', () => {
      const results = createSampleResults();
      const comment = formatter.formatTestResults(results);

      expect(comment).toContain('üìä View Full HTML Report');
      expect(comment).toContain('üì¶ Download Artifacts');
    });

    it('should include footer with version', () => {
      const results = createSampleResults();
      const comment = formatter.formatTestResults(results);

      expect(comment).toContain('Generated by');
      expect(comment).toContain('API Test Agent');
      expect(comment).toContain('v1.0.0');
    });

    it('should handle results with only passed tests', () => {
      const results = createAllPassedResults();
      const comment = formatter.formatTestResults(results);

      expect(comment).toContain('‚úÖ **3 passed**');
      expect(comment).not.toContain('### ‚ùå Failed Tests');
      expect(comment).not.toContain('### üîß Self-Healed Tests');
    });

    it('should handle results with only failed tests', () => {
      const results = createAllFailedResults();
      const comment = formatter.formatTestResults(results);

      expect(comment).toContain('‚ùå **2 failed**');
      expect(comment).not.toContain('### ‚úÖ Passed Tests');
    });

    it('should handle empty test results', () => {
      const results = createEmptyResults();
      const comment = formatter.formatTestResults(results);

      expect(comment).toContain('## üß™ API Test Results');
      expect(comment).toContain('### Summary');
      expect(comment).toContain('Generated by');
    });

    it('should truncate very long comments', () => {
      const results = createVeryLongResults();
      const comment = formatter.formatTestResults(results);

      expect(comment.length).toBeLessThanOrEqual(65536);
      if (comment.length === 65536) {
        expect(comment).toContain('Comment truncated');
      }
    });
  });

  describe('formatSummary', () => {
    it('should format summary with all status types', () => {
      const results = createSampleResults();
      const summary = formatter.formatSummary(results);

      expect(summary).toContain('### Summary');
      expect(summary).toContain('‚úÖ **2 passed**');
      expect(summary).toContain('‚ùå **1 failed**');
      expect(summary).toContain('‚è≠Ô∏è **1 skipped**');
      expect(summary).toContain('üîß **1 self-healed**');
    });

    it('should display duration in correct format', () => {
      const results = createSampleResults();
      const summary = formatter.formatSummary(results);

      expect(summary).toContain('Duration:');
      expect(summary).toMatch(/\d+(\.\d+)?[ms]/);
    });

    it('should display coverage when available', () => {
      const results = createSampleResults();
      const summary = formatter.formatSummary(results);

      expect(summary).toContain('Coverage: 87.0%');
    });

    it('should display success rate with progress bar', () => {
      const results = createSampleResults();
      const summary = formatter.formatSummary(results);

      expect(summary).toContain('Success Rate');
      expect(summary).toContain('%');
      expect(summary).toMatch(/\[‚ñà+‚ñë*\]/); // Progress bar pattern
    });

    it('should handle 100% success rate', () => {
      const results = createAllPassedResults();
      const summary = formatter.formatSummary(results);

      expect(summary).toContain('100.0%');
      expect(summary).toContain('[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà]'); // Full bar
    });

    it('should handle 0% success rate', () => {
      const results = createAllFailedResults();
      const summary = formatter.formatSummary(results);

      expect(summary).toContain('0.0%');
      expect(summary).toContain('[‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]'); // Empty bar
    });
  });

  describe('formatPassedTests', () => {
    it('should list passed tests with duration', () => {
      const tests = createPassedTests(3);
      const formatted = formatter.formatPassedTests(tests);

      expect(formatted).toContain('### ‚úÖ Passed Tests (3)');
      expect(formatted).toContain('test-0');
      expect(formatted).toContain('test-1');
      expect(formatted).toContain('test-2');
    });

    it('should collapse tests beyond first 5', () => {
      const tests = createPassedTests(10);
      const formatted = formatter.formatPassedTests(tests);

      expect(formatted).toContain('Show 5 more passed tests');
      expect(formatted).toContain('<details>');
      expect(formatted).toContain('</details>');
    });

    it('should show all tests if 5 or fewer', () => {
      const tests = createPassedTests(5);
      const formatted = formatter.formatPassedTests(tests);

      expect(formatted).not.toContain('<details>');
      expect(formatted).not.toContain('Show');
    });

    it('should handle empty passed tests', () => {
      const tests: TestResult[] = [];
      const formatted = formatter.formatPassedTests(tests);

      expect(formatted).toContain('### ‚úÖ Passed Tests (0)');
      expect(formatted).not.toContain('<details>');
    });
  });

  describe('formatFailedTests', () => {
    it('should format failed tests with details', () => {
      const tests = createFailedTests(2);
      const formatted = formatter.formatFailedTests(tests, true);

      expect(formatted).toContain('### ‚ùå Failed Tests (2)');
      expect(formatted).toContain('failed-test-0');
      expect(formatted).toContain('failed-test-1');
    });

    it('should include error messages', () => {
      const tests = createFailedTests(1);
      const formatted = formatter.formatFailedTests(tests, true);

      expect(formatted).toContain('Error');
      expect(formatted).toContain('Test assertion failed');
    });

    it('should include stack traces in collapsible sections', () => {
      const tests = createFailedTests(1);
      const formatted = formatter.formatFailedTests(tests, true);

      expect(formatted).toContain('<details>');
      expect(formatted).toContain('Stack Trace');
      expect(formatted).toContain('</details>');
    });

    it('should include expected vs actual when available', () => {
      const tests = createFailedTestsWithComparison();
      const formatted = formatter.formatFailedTests(tests, true);

      expect(formatted).toContain('Expected vs Actual');
      expect(formatted).toContain('```json');
      expect(formatted).toContain('Expected:');
      expect(formatted).toContain('Actual:');
    });

    it('should format without details when detailed=false', () => {
      const tests = createFailedTests(2);
      const formatted = formatter.formatFailedTests(tests, false);

      expect(formatted).toContain('### ‚ùå Failed Tests (2)');
      expect(formatted).not.toContain('<details>');
      expect(formatted).not.toContain('Error:');
    });

    it('should handle empty failed tests', () => {
      const tests: TestResult[] = [];
      const formatted = formatter.formatFailedTests(tests, true);

      expect(formatted).toContain('### ‚ùå Failed Tests (0)');
    });

    it('should include retry information', () => {
      const tests = createFailedTestsWithRetries();
      const formatted = formatter.formatFailedTests(tests, true);

      expect(formatted).toContain('**Retries**: 3');
    });

    it('should include error location', () => {
      const tests = createFailedTestsWithLocation();
      const formatted = formatter.formatFailedTests(tests, true);

      expect(formatted).toContain('Location');
      expect(formatted).toContain('test.ts:42:10');
    });
  });

  describe('formatHealedTests', () => {
    it('should format healed tests with descriptions', () => {
      const healedTests = createHealedTests(2);
      const formatted = formatter.formatHealedTests(healedTests);

      expect(formatted).toContain('### üîß Self-Healed Tests (2)');
      expect(formatted).toContain('auto-fixed');
    });

    it('should include healing descriptions', () => {
      const healedTests = createHealedTests(1);
      const formatted = formatter.formatHealedTests(healedTests);

      expect(formatted).toContain('Field renamed');
    });

    it('should show strategy emojis', () => {
      const healedTests: HealedTest[] = [
        createHealedTest('test-1', 'ai-powered'),
        createHealedTest('test-2', 'rule-based'),
        createHealedTest('test-3', 'hybrid'),
      ];
      const formatted = formatter.formatHealedTests(healedTests);

      expect(formatted).toContain('ü§ñ'); // AI
      expect(formatted).toContain('üìè'); // Rule-based
      expect(formatted).toContain('üîÄ'); // Hybrid
    });

    it('should only show successful heals', () => {
      const healedTests = [
        { ...createHealedTest('test-1', 'ai-powered'), success: true },
        { ...createHealedTest('test-2', 'ai-powered'), success: false },
      ];
      const formatted = formatter.formatHealedTests(healedTests);

      expect(formatted).toContain('### üîß Self-Healed Tests (1)');
      expect(formatted).toContain('test-1');
      expect(formatted).not.toContain('test-2');
    });

    it('should return empty for no successful heals', () => {
      const healedTests = [{ ...createHealedTest('test-1', 'ai-powered'), success: false }];
      const formatted = formatter.formatHealedTests(healedTests);

      expect(formatted).toBe('');
    });
  });

  describe('formatPerformanceMetrics', () => {
    it('should format all performance metrics', () => {
      const metrics = createPerformanceMetrics();
      const formatted = formatter.formatPerformanceMetrics(metrics);

      expect(formatted).toContain('### üìà Performance Metrics');
      expect(formatted).toContain('Average Response Time');
      expect(formatted).toContain('Slowest Endpoint');
      expect(formatted).toContain('Fastest Endpoint');
      expect(formatted).toContain('Throughput');
      expect(formatted).toContain('Total Requests');
    });

    it('should format durations correctly', () => {
      const metrics = createPerformanceMetrics();
      const formatted = formatter.formatPerformanceMetrics(metrics);

      expect(formatted).toMatch(/\d+(\.\d+)?[ms]/);
    });

    it('should handle missing optional fields', () => {
      const metrics: PerformanceMetrics = {
        averageResponseTime: 100,
        totalRequests: 50,
        requestsPerSecond: 10,
      };
      const formatted = formatter.formatPerformanceMetrics(metrics);

      expect(formatted).toContain('Average Response Time');
      expect(formatted).not.toContain('Slowest Endpoint');
      expect(formatted).not.toContain('Fastest Endpoint');
    });
  });

  describe('createCollapsibleSection', () => {
    it('should create HTML details/summary section', () => {
      const section = formatter.createCollapsibleSection('Click me', 'Hidden content');

      expect(section).toContain('<details>');
      expect(section).toContain('<summary>Click me</summary>');
      expect(section).toContain('Hidden content');
      expect(section).toContain('</details>');
    });

    it('should preserve markdown in content', () => {
      const content = '**Bold** and `code`';
      const section = formatter.createCollapsibleSection('Title', content);

      expect(section).toContain('**Bold**');
      expect(section).toContain('`code`');
    });
  });

  describe('addEmojis', () => {
    it('should add emojis for status keywords', () => {
      const text = 'Test passed successfully';
      const result = formatter.addEmojis(text);

      expect(result).toContain('‚úÖ');
    });

    it('should add emojis for failure keywords', () => {
      const text = 'Test failed with error';
      const result = formatter.addEmojis(text);

      expect(result).toContain('‚ùå');
    });

    it('should add emojis for warning keywords', () => {
      const text = 'Warning: deprecated API';
      const result = formatter.addEmojis(text);

      expect(result).toContain('‚ö†Ô∏è');
    });

    it('should handle text without keywords', () => {
      const text = 'Some random text';
      const result = formatter.addEmojis(text);

      expect(result).toBe(text);
    });
  });

  describe('truncateIfNeeded', () => {
    it('should not truncate short content', () => {
      const content = 'Short content';
      const result = formatter.truncateIfNeeded(content, 1000);

      expect(result).toBe(content);
    });

    it('should truncate long content', () => {
      const content = 'x'.repeat(100000);
      const result = formatter.truncateIfNeeded(content, 1000);

      expect(result.length).toBeLessThan(content.length);
      expect(result).toContain('Comment truncated');
    });

    it('should preserve markdown structure when truncating', () => {
      const content = '# Header\n\n' + 'Content\n'.repeat(10000);
      const result = formatter.truncateIfNeeded(content, 1000);

      expect(result).not.toContain('# Header\nContent'); // Should break at newline
    });
  });

  describe('generateReportLink', () => {
    it('should generate valid report URL', () => {
      const reportId = 'abc123';
      const url = formatter.generateReportLink(reportId);

      expect(url).toContain(reportId);
      expect(url).toMatch(/^https?:\/\//);
    });
  });

  describe('generateSummaryComment', () => {
    it('should generate brief summary for all passed', () => {
      const results = createAllPassedResults();
      const summary = formatter.generateSummaryComment(results);

      expect(summary).toContain('‚úÖ All tests passed!');
      expect(summary).toContain('3/3');
    });

    it('should generate brief summary for failures', () => {
      const results = createSampleResults();
      const summary = formatter.generateSummaryComment(results);

      expect(summary).toContain('‚ùå Some tests failed');
    });

    it('should include duration', () => {
      const results = createSampleResults();
      const summary = formatter.generateSummaryComment(results);

      expect(summary).toMatch(/in \d+(\.\d+)?[ms]/);
    });
  });

  describe('generateCompactComment', () => {
    it('should generate compact comment with essential info', () => {
      const results = createSampleResults();
      const comment = formatter.generateCompactComment(results);

      expect(comment).toContain('## üß™ API Test Results');
      expect(comment).toContain('### Summary');
      expect(comment).toContain('### ‚ùå Failed Tests');
      expect(comment).not.toContain('<details>'); // Compact version
    });

    it('should be shorter than full comment', () => {
      const results = createSampleResults();
      const fullComment = formatter.formatTestResults(results);
      const compactComment = formatter.generateCompactComment(results);

      expect(compactComment.length).toBeLessThan(fullComment.length);
    });
  });

  describe('edge cases', () => {
    it('should handle test with no error details', () => {
      const test: TestResult = {
        id: 'test-1',
        name: 'Broken test',
        filePath: 'test.ts',
        status: TestStatus.FAILED,
        duration: 100,
        retries: 0,
        startTime: new Date(),
        endTime: new Date(),
      };

      const formatted = formatter.formatFailedTests([test], true);
      expect(formatted).toContain('Broken test');
    });

    it('should handle very long test names', () => {
      const test = createPassedTest('x'.repeat(500));
      const formatted = formatter.formatPassedTests([test]);

      expect(formatted).toContain('x'.repeat(500));
    });

    it('should handle special characters in test names', () => {
      const test = createPassedTest('Test [with] (special) {chars}');
      const formatted = formatter.formatPassedTests([test]);

      expect(formatted).toBeDefined();
    });

    it('should handle zero duration tests', () => {
      const test = { ...createPassedTest('fast-test'), duration: 0 };
      const formatted = formatter.formatPassedTests([test]);

      expect(formatted).toContain('0ms');
    });

    it('should handle very long duration tests', () => {
      const test = { ...createPassedTest('slow-test'), duration: 300000 }; // 5 minutes
      const formatted = formatter.formatPassedTests([test]);

      expect(formatted).toContain('5m');
    });
  });
});

// Helper functions

function createSampleResults(): FormattedTestResults {
  const tests = [
    ...createPassedTests(2),
    ...createFailedTests(1),
    createSkippedTest(),
  ];

  return {
    summary: {
      totalTests: 4,
      passed: 2,
      failed: 1,
      skipped: 1,
      timeout: 0,
      error: 0,
      duration: 5200,
      startTime: new Date(),
      endTime: new Date(),
      successRate: 0.5,
      averageDuration: 1300,
      filesExecuted: ['test.ts'],
      totalRetries: 0,
      byFile: {},
    },
    tests,
    failedTests: tests.filter((t) => t.status === TestStatus.FAILED),
    healedTests: [createHealedTest('healed-test', 'ai-powered')],
    metrics: createPerformanceMetrics(),
    reportUrl: 'https://example.com/report/123',
    artifactUrl: 'https://example.com/artifacts/456',
    runId: '789',
  };
}

function createAllPassedResults(): FormattedTestResults {
  const tests = createPassedTests(3);
  return {
    summary: {
      totalTests: 3,
      passed: 3,
      failed: 0,
      skipped: 0,
      timeout: 0,
      error: 0,
      duration: 1500,
      startTime: new Date(),
      endTime: new Date(),
      successRate: 1.0,
      averageDuration: 500,
      filesExecuted: ['test.ts'],
      totalRetries: 0,
      byFile: {},
    },
    tests,
    failedTests: [],
    healedTests: [],
  };
}

function createAllFailedResults(): FormattedTestResults {
  const tests = createFailedTests(2);
  return {
    summary: {
      totalTests: 2,
      passed: 0,
      failed: 2,
      skipped: 0,
      timeout: 0,
      error: 0,
      duration: 1000,
      startTime: new Date(),
      endTime: new Date(),
      successRate: 0,
      averageDuration: 500,
      filesExecuted: ['test.ts'],
      totalRetries: 0,
      byFile: {},
    },
    tests,
    failedTests: tests,
    healedTests: [],
  };
}

function createEmptyResults(): FormattedTestResults {
  return {
    summary: {
      totalTests: 0,
      passed: 0,
      failed: 0,
      skipped: 0,
      timeout: 0,
      error: 0,
      duration: 0,
      startTime: new Date(),
      endTime: new Date(),
      successRate: 0,
      averageDuration: 0,
      filesExecuted: [],
      totalRetries: 0,
      byFile: {},
    },
    tests: [],
    failedTests: [],
    healedTests: [],
  };
}

function createVeryLongResults(): FormattedTestResults {
  const tests = createPassedTests(1000);
  return {
    summary: {
      totalTests: 1000,
      passed: 1000,
      failed: 0,
      skipped: 0,
      timeout: 0,
      error: 0,
      duration: 50000,
      startTime: new Date(),
      endTime: new Date(),
      successRate: 1.0,
      averageDuration: 50,
      filesExecuted: ['test.ts'],
      totalRetries: 0,
      byFile: {},
    },
    tests,
    failedTests: [],
    healedTests: [],
  };
}

function createPassedTests(count: number): TestResult[] {
  return Array.from({ length: count }, (_, i) => createPassedTest(`test-${i}`));
}

function createPassedTest(name: string): TestResult {
  return {
    id: `id-${name}`,
    name,
    filePath: 'test.ts',
    status: TestStatus.PASSED,
    duration: Math.random() * 1000,
    retries: 0,
    startTime: new Date(),
    endTime: new Date(),
  };
}

function createFailedTests(count: number): TestResult[] {
  return Array.from({ length: count }, (_, i) => ({
    id: `failed-${i}`,
    name: `failed-test-${i}`,
    filePath: 'test.ts',
    status: TestStatus.FAILED,
    duration: 500,
    retries: 0,
    startTime: new Date(),
    endTime: new Date(),
    error: {
      message: 'Test assertion failed',
      type: ErrorType.ASSERTION,
      stack: 'Error: Test assertion failed\n  at test.ts:10:5\n  at Runner.run:20:10',
    },
  }));
}

function createFailedTestsWithComparison(): TestResult[] {
  return [
    {
      id: 'failed-comparison',
      name: 'Test with comparison',
      filePath: 'test.ts',
      status: TestStatus.FAILED,
      duration: 500,
      retries: 0,
      startTime: new Date(),
      endTime: new Date(),
      error: {
        message: 'Values do not match',
        type: ErrorType.ASSERTION,
        comparison: {
          expected: { status: 200, body: { id: 1 } },
          actual: { status: 404, body: null },
        },
      },
    },
  ];
}

function createFailedTestsWithRetries(): TestResult[] {
  return [
    {
      id: 'failed-retries',
      name: 'Test with retries',
      filePath: 'test.ts',
      status: TestStatus.FAILED,
      duration: 500,
      retries: 3,
      startTime: new Date(),
      endTime: new Date(),
      error: {
        message: 'Test failed after retries',
        type: ErrorType.NETWORK,
      },
    },
  ];
}

function createFailedTestsWithLocation(): TestResult[] {
  return [
    {
      id: 'failed-location',
      name: 'Test with location',
      filePath: 'test.ts',
      status: TestStatus.FAILED,
      duration: 500,
      retries: 0,
      startTime: new Date(),
      endTime: new Date(),
      error: {
        message: 'Assertion error',
        type: ErrorType.ASSERTION,
        location: {
          file: 'test.ts',
          line: 42,
          column: 10,
        },
      },
    },
  ];
}

function createSkippedTest(): TestResult {
  return {
    id: 'skipped-1',
    name: 'Skipped test',
    filePath: 'test.ts',
    status: TestStatus.SKIPPED,
    duration: 0,
    retries: 0,
    startTime: new Date(),
    endTime: new Date(),
  };
}

function createHealedTests(count: number): HealedTest[] {
  return Array.from({ length: count }, (_, i) =>
    createHealedTest(`healed-${i}`, 'ai-powered')
  );
}

function createHealedTest(name: string, strategy: 'ai-powered' | 'rule-based' | 'hybrid'): HealedTest {
  return {
    test: createPassedTest(name),
    healingDescription: 'Field renamed from "price" to "cost"',
    strategy,
    success: true,
  };
}

function createPerformanceMetrics(): PerformanceMetrics {
  return {
    averageResponseTime: 156,
    slowestEndpoint: {
      name: 'GET /orders',
      duration: 1200,
    },
    fastestEndpoint: {
      name: 'GET /health',
      duration: 12,
    },
    totalRequests: 25,
    requestsPerSecond: 5.5,
    coverage: 87,
  };
}
